{% extends "base.html" %}
{% set active_page = "CORS" %}
{% block title %}CORS{% endblock %}
{% block content %}
<div class="container main">
	<div class="row">
		<h1>Cross-Origin Resource Sharing</h1>
		<div class="col-md-3">
			<ul class="nav nav-stacked" id="side-nav" data-spy="affix" data-offset-top="75">
				<li><a href="#nav-introduction">Introduction<span class="glyphicon glyphicon-chevron-right"></span></a></li>
				<li><a href="#nav-cors">CORS<span class="glyphicon glyphicon-chevron-right"></span></a></li>
				<li><a href="#nav-howitworks">How It Works<span class="glyphicon glyphicon-chevron-right"></span></a></li>
				<li><a href="#nav-alternatives">Alternatives<span class="glyphicon glyphicon-chevron-right"></span></a></li>
			</ul>
		</div>
		
		<div class="col-md-9" role="main" data-spy="scroll" data-target="#side-nav">
			<div id="nav-introduction">
				<h2>Introduction</h2>
				<p>
					With increasing risk, web developers needed an easy solution for safely sharing content cross-domain.  
					Unfortunately with the Same-Origin-Policy (SOP), the sharing of these resources are extremely limited and
					at times almost impossible.
				</p>
				<p>
					Because the attacks are generally generated by injecting malicious code through form posts, one may think 
					that a largely static page could afford to disable SOP to allow, for instance, gathering data from a separate domain. 
					There are two major reasons why this wouldn't work: First, this is extremely insecure as not all attacks 
					rely on injecting malicious commands into submission forms.  Second, disabling the policy is impossible with 
					JavaScript.  Users can disable it themselves (for example, passing --disable-web-security to Chrome will 
					disable same-origin policy in Chrome for that session), but that would still lead to security issues for other sites.
				</p>
			</div>
			
			<div id="nav-cors">
				<h2>Cross-Origin Resource Sharing</h2>
				<p>
					CORS is a specification to circumvent SOP while attempting to remain safe. Like the Same-Origin 
					Policy, it is depended on the browser to enable functionality.  Fortunately, most popular browsers support CORS: 
					a few examples being Firefox, SeaMonkey, Safari, Chrome, Internet Explorer, and Opera in their modern iteration.  
					Thus, developers can be reasonably certain that virtually all of their users will probably be using a CORS-supported
					browser.
				</p>
				<p>
					CORS allows requests to be made to other domains because CORS-enabled servers specify which domains are allowed to request  
					content.  There are several APIs that utilize CORS including but not limited to: Amazon S3, Dropbox API, Google's various APIs, and YouTube 
					API.  There are also several libraries to easily implement CORS such as CORS Filter (Java) and cors-python (Python). 
				</p>
			</div>
			
			<div id="nav-howitworks">
				<h2>How It Works</h2>
				<p>
					CORS works by adding HTTP headers to tell which origins are allowed, allowing web developers to specify which particular resources 
					they would like to use, while still remaining secure from outside threats as well as injected attacks. Specifying the origin for 
					a page is incredibly easy. The header may be "Origin: http://www.somesite.com", where specifying some sites are allowed through 
					CORS is as simple as "Access-Control-Allow-Origin: http://www.othersite.com". The tutorial section of this site will go into more 
					detail about this process.
				</p>
				<p>
					There are several reasons why CORS is prefered over alternatives. To start, it's simpler to use than JSONP, allowing newer users 
					to adapt quickly to the technology. It also allows for more than just the GET command, expanding functionality greatly.
				</p>
				<p>
					There are some downsides to CORS as well. A inappropriately configured CORS (such as allowing all sites with Access-Control-Allow-Origin: 
					*) can open up gaping security holes and make a website more vulnerable than if it was not using CORS at all. Also, very old versions of 
					popular browsers do not support CORS, so if a user happens to be using one of those, they will be forced to upgrade or not experience the site.
				</p>
			</div>
			
			<div id="nav-alternatives">
				<h2>JSONP as an Alternative</h2>
				<p>
					There are a few ways safely around this same-origin policy. One such is JSONP (JavaScript Object Notation with Padding). JSONP 
					allows users to call data from a different server without conflicting with the same-origin policy. Usually, the only way to contact 
					information from one domain to another is with the ;&lt;script&gt; tag in HTML, but this generally doesn't return anything useable - 
					the script just gets evaluated. JSONP allows one to make a request to a JSONP enabled server and give information about what is needed, 
					so the given domain can appropriately respond. This allows one to make requests that will then be processed by a function. However, 
					because JSONP is still Javascript, there is still a level of trust required for the provider of the JSONP data. Essentially, if 
					their system becomes compromised, the information they send back could be a compromising XSS attack! Workarounds are present, such 
					as requesting a string you can clean to ensure against injection XSS attacks. You must also trust the validity of the request, as 
					failures from time out or a misunderstood request cannot be returned using this method. These shortcomings combined with JSONP only 
					supporting GET requests makes CORS a more modern alternative for developers.
				</p>
			</div>
		</div>
	</div>
</div>
{% endblock %}