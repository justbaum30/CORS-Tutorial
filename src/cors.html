{% extends "base.html" %}
{% set active_page = "CORS" %}
{% block title %}CORS{% endblock %}
{% block content %}
<div class="container main">
	<div class="row">
		<h1>Cross-Origin Resource Sharing</h1>
		<div class="col-md-3">
			<ul class="nav nav-stacked" id="side-nav" data-spy="affix" data-offset-top="75">
				<li><a href="#nav-introduction">Introduction<span class="glyphicon glyphicon-chevron-right"></span></a></li>
				<li><a href="#nav-cors">CORS<span class="glyphicon glyphicon-chevron-right"></span></a></li>
				<li><a href="#nav-alternatives">Alternatives<span class="glyphicon glyphicon-chevron-right"></span></a></li>
			</ul>
		</div>
		
		<div class="col-md-9" role="main" data-spy="scroll" data-target="#side-nav">
			<div id="nav-introduction">
				<h2>Introduction</h2>
				<p>With increasing risk, web developers needed an easy solution for allowing content without opening themselves for attack. 
					This was one of the driving forces behind the same-origin policy, a mechanism that disallowed programming languages 
					within a browser (notably JavaScript) to only run if the script originated from the same site. 
				</p>
				<p>
					The same-origin policy is effective, but perhaps too restrictive. Websites that use multiple subdomains (en.site.com 
					vs fr.site.com for English and French versions of the same site) and websites relying on scripts and content from other 
					sites (such as implementing a PayPal payment widget) are some examples of the same-origin policy causing problems for 
					web developers.
				</p>
				<p>
					Developers cannot simply disable same-origin policy. Because the attacks are generally generated by injecting malicious 
					code through submission forms, one may think that a largely static page could afford to disable the same-origin policy 
					to allow, for instance, gathering data from another of their subdomains. There are two major reasons why this wouldn't 
					work: The first is that this is not secure, as not all attacks rely on injecting malicious commands into submission forms; 
					The second is that same-origin policy is enforced by the browser, not the server, and disabling the policy is impossible 
					with code from a website. Users could disable it themselves (for example, passing --disable-web-security to Chrome will 
					disable same-origin policy in Chrome for that session), but that would still lead to security issues for sites.
				</p>
			</div>
			
			<div id="nav-cors">
				<h2>Cross-Origin Resource Sharing</h2>
				<p>
					Cross-Origin Resource Sharing is a way around the same-origin policy while attempting to remain safe. Like the same-origin 
					policy, it is implemented browser-side to enable functionality. Most popular browsers support CORS: a few examples being 
					Firefox, SeaMonkey, Safari, Chrome, Internet Explorer, and Opera in their modern iteration. Thus, users of CORS can be 
					reasonably certain that virtually all of their uses will have access to a CORS supported browser, and will probably be using 
					a supported browser already.
				</p>
				<p>
					CORS allows requests to be made to other domains because CORS specifies which domains are allowed and then only allows specific 
					otherwise-same-origin-policy breaking content for those specific domains. Several API's support CORS to allow them to be used 
					throughout the internet, including but not limited to: Amazon S3, Dropbox API, Google's various APIs, and YouTube API. There 
					are also several libraries for implementing CORS, ranging from CORS Filter (For Java), cors-python (for Python), and more. 
				</p>
				<p>
					COR works by adding HTTP headers to tell which origins are allowed, allowing the site creator to specify which particular resources 
					they would like to use, while still remaining secure from outside threats as well as injected attacks. Specifying the origin for 
					a page is incredibly easy. The header may be "Origin: http://www.somesite.com", where specifying some sites are allowed through 
					CORS is as simple as "Access-Control-Allow-Origin: http://www.othersite.com". The tutorial section of this site will go into more 
					detail about this process.
				</p>
				<p>
					There are several reasons why CORS is prefered over alternatives. To start, it's simpler to use than JSONP, allowing newer users 
					to adapt quickly to the technology. It also allows for more than just the GET command, expanding functionality greatly.
				</p>
				<p>
					There are some downsides to CORS as well. A inappropriately configured CORS (such as allowing all sites with Access-Control-Allow-Origin: 
					*) can open up gaping security holes and make a website more vulnerable than if it was not using CORS at all. Also, very old versions of 
					popular browsers do not support CORS, so if a user happens to be using one of those, they will be forced to upgrade or not experience the site.
				</p>
			</div>
			
			<div id="nav-alternatives">
				<h2>JSONP as an Alternative</h2>
				<p>
					There are a few ways safely around this same-origin policy. One such is JSONP (JavaScript Object Notation with Padding). JSONP 
					allows users to call data from a different server without conflicting with the same-origin policy. Usually, the only way to contact 
					information from one domain to another is with the ;&lt;script&gt; tag in HTML, but this generally doesn't return anything useable - 
					the script just gets evaluated. JSONP allows one to make a request to a JSONP enabled server and give information about what is needed, 
					so the given domain can appropriately respond. This allows one to make requests that will then be processed by a function. However, 
					because JSONP is still Javascript, there is still a level of trust required for the provider of the JSONP data. Essentially, if 
					their system becomes compromised, the information they send back could be a compromising XSS attack! Workarounds are present, such 
					as requesting a string you can clean to ensure against injection XSS attacks. You must also trust the validity of the request, as 
					failures from time out or a misunderstood request cannot be returned using this method. These shortcomings combined with JSONP only 
					supporting GET requests makes CORS a more modern alternative for developers.
				</p>
			</div>
		</div>
	</div>
</div>
{% endblock %}